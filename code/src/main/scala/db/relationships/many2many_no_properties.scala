package db.relationships

import molecule.DomainStructure

object many2many_no_properties extends DomainStructure {

  trait Employee {
    val name     = oneString
    val projects = many[Project] // (no underscore needed - no single defining side)
  }

  trait Project {
    val name      = oneString
    val employees = many[Employee] // (no underscore needed - no single defining side)
  }


  // Automatically generated by Molecule
  trait Employee_projects_Project {
    val employee_id = oneLong
    val project_id  = oneLong
  }

//  // Most meaningful/common way of making the joins
//  val List(bob, liz)    = Employee.name.insert("Bob", "Liz").transact.ids
//  val List(scala, java) = Project.name.insert("Scala", "Java").transact.ids
//  Employee_projects_Project.employee_id.project_id.insert(
//    (bob, scala),
//    (bob, java),
//    (liz, scala)
//  ).transact
//
//  // I'm not sure if I should allow creating both sides at once like this...
//  Employee.name.Projects.*(Project.name).insert("Bob", List("Scala", "Java")).transact
//  // or
//  Project.name.Employees.*(Employee.name).insert("Scala", List("Bob", "Liz")).transact
//  // This last approach kind of goes against the whole point of many-to-many
//  // relationships since it doesn't work to insert the same entity twice.
//  // This kind of nested insert should probably only be allowed for one-many inserts
//  // like the invoice-invoiceLines example.


}